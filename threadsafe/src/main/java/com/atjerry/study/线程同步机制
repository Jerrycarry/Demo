线程的安全问题与线程的同步机制

1.多线程买票，出现的问题:出现重票和错票

2.什么原因导致的？线程1操作ticket的过程中，尚未结束的情况下，其他线程也参与进来，对ticket进行操作。

3.如何解决？必须保证一个线程a在进行操作ticket的过程中，其他线程必须等待，知道线程a操作ticket结束以后，其他线程才可以进入继续操作ticket

4.Java是如何解决线程安全的问题的?使用线程的同步机制。

方式1：同步代码块

synchronized(同步监视器){
    //需要被同步的代码
}
说明：
>需要被同步的代码，即为操作共享数据的代码。
>共享数据：即多个线程多需要操作的数据。比如：ticket
>需要被同步的代码，在被synchronized包裹以后，就使得一个线程在操作这些代码的过程中，其他线程必须等待。
>同步监视器简称锁 哪个线程获取了锁，哪个线程就能执行需要被同步的代码
>同步监视器
可以使用任何一个类的对象充当。但是，多个线程必须共用同一个同步监视器
方式2：同步方法

说明：如果共享数据的代码完整的声明在一个方法中，那么我们将此方法声明为同步方法即可
>非静态同步方法，默认监视器为this。
>静态同步方法，默认监视器为当前类本身。




5.synchronized好处：解决线程安全问题
弊端：在操作共享数据时，多线程其实时串行执行的，意味着性能低。